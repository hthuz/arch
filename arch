# Arch Linux Note 

This is my learning note of all kinds of things as I'm trying to be familiar with Linux as a rookie. Some contents may not be written in detail as I'm already familiar with relevent concepts. So the learning note is somewhat personalized. Also note that some materials are cited from some books/websites. Because of my laziness I won't cite them in this note but I do appreciate all of these materials.

## Pacman

-S supports search/query in the sync database  
-Q supports search/query in the local database  

CMD                     | Description
-----------------       | -------------
`pacman -Rs`        | --recursive, Remove package and dependency(not required by other packages)
`pacman -Sg`        | --group, list package groups(sync)
`pacman -Si`        | --info, Extensive search, (sync)
`pacman -Ss`        | --search, Detailed search package, supports regexp(sync)
`pacman -Su`        | --sysupgrade, Update all out-of-date packages
`pacman -Sy`        | --refresh, download a fresh copy of master package database from server, pass two to force
`pacman -F <name>`  | Query the file database, -F means --files
`pacman -Q <name>`  | Search local package, query the package database
`pacman -Q`         | List all local packages
`pacman -Qc `       | --changelog
`pacman -Qd`        | --deps, list packages installed as depedencies
`pacman -Qg`        | --groups, list package groups(local)
`pacman -Qi `       | --info, Extensive search local packages
`pacman -Ql`        | --l, list all files owned by the package
`pacman -Qm`        | --foreign, list packages not found in sync database(from AUR, for example)
`pacman -Qo <file>` | --own, Search for packages that owns this file
`pacman -Qs <regexp>`| --search, Detailed search local packages, supports search by regexp
`pacman -Qt`        | --unrequired, list packages not required by ohter packages
`pacman -Qu`        | --upgrade, list out-of-date packages


Options                 | Description  
--                      | --  
--ignore pkg1,pkg2      | Applies to -S,-U, ignore upgrades even if there is one available

local database: `/var/lib/pacman/local`  
sync database: `/var/lib/pacman/sync`
pacman mirrorlist: `/etc/pacman.d/mirrorlist`  
`pacman -Syyu` to sync modified mirrolist  
pacman configuration file: `/etc/pacman.conf`

### Cache Clean

Cache directory in `/var/cache/pacman/pkg/`

Use `paccache` from `pacman-contrib`

| Cmd            | Description                                                      |
|----------------+------------------------------------------------------------------|
| paccache -ruk0 | Remove all uninstalled package cache                             |
| paccache -r    | Remove package cache, keep cache of latest 3 versions by default |
| paccache -rk2  | 2 specifies keep latest 2 versions only                          |

## systemmd  

PID 1, system and service manager  
Units: service, mount, device, socket  


CMD                                   | DESCRIPTION
--                                    | --
`systemctl status`                    |
`systemctl list-units`                |
`systemctl list-units --type=service` | list service only
`systemctl start unit`                | start a unit immediately
`systemctl stop unit`                 | stop a unit immediately
`systemctl enable unit`               | start automatically at boot
`systemctl enable --now unit`         | start automatically at boot and start it now
`systemctl disable unit`              | no longer start at boot
`systemctl mask unit`                 | impossible to start
`systemctl unmask unit`               |

## Booting Process

BIOS->Boot Loader->Kernel Initialization->init(or systemctl) process

init will start other processes.
From the user side, example as follows(generated by `pstree`)

```shell
systemd─┬─NetworkManager───3*[{NetworkManager}]
        |-login-bash
        ├─dbus-daemon
        ├─systemd-journal
        ├─systemd-logind
        ├─systemd-udevd
        └─wpa_supplicant
```

`bash` will load `.bash_profile` and `.bashrc`.

For example, if I run `chadwm`, orders are as follows:
bash->startx(in `.bash_profile`, exec cmds in `.xinitrc`)->chadwm start script

## Environment Variables  

| CMD                             | Description                                                                 |
|---------------------------------|-----------------------------------------------------------------------------|
| `printenv <var>`                | print one variable                                                          |
| `printenv`                      | print all environment variables                                             |
| `set`                           | print all variables(including shell var etc)                                |
| `unset <var>`                       | Delete a environment variable |
| `set <myvar>`                   | set a var(not env)                                                          |
| `export <myvar>`                | set <myvar> to env, only change env var of my child processes               |
| `export MYVAR=content`          | directly set env var (temporary)                                            |
| add env var in /etc/environment | persistent env var(system-wide)                                             |
| add env var in /etc/profile     | persistent env var(user-wide), need to source this file         |
| add script in /etc/profile.d    | /etc/profile.d is a dir containing script export PATH                       |
| add env var in /etc/bashrc      | env var for bash shell only                                                 |
| add env var in ~/.bash_profile  | env var for bash shell only, this file is executed only once on sys startup |

Environment varialbe $PATH: list of directories to be searched when executing command  

In command-line, you can add `VAR=value` in front of the command to temporarily change the environmental variable for this command. Example:`LANG=C ls .`

To remove one directory in $PATH, run
```bash
PATH=$(echo "$PATH" | sed -e 's/:\/home\/autentico\/sthsth$//')
```

## DWM  
Better to Add:  st, dmenu, dwm  
Use git clone and make install
/usr/share/xsessions/dwm.desktop content:  
```txt
[Desktop Entry]
Encoding=UTF-8
Name=dwm
Comment=Dynamic Window Manager  
Exec=dwm
Icon=dwm
Type=xsession
```


Default Shortcut                    | Description  
--                          | --
shift+alt+enter             | open st
shift+alt+c                 | close window
shift+alt+q                 | quit dwm
alt+j/k                     | change window
alt+p                       | open dmenu
alt+enter                   | set current window as master window  
alt+m/t                     | change full screen
alt+1-9                     | change tag             
alt+f                       | change current window to floating mode
alt + m                     | change current window to full screen
alt + t                     | recover mode
alt + i                     | Change layout of clients to equal mode

Apply patches 'patch --merge -i <patch.diff>'


## xorg

Check if it's X11 or wayland: `echo $XDG_SESSION_TYPE`

### xinit
Used to start window managers  
Default configuration file: `/etc/X11/xinit/xinitrc`  
Configuration file in home directory :`~/.xinitrc`  
Note commands after `exec` won't be executed  

To start, run `startx` or set auto start 

#### Autostart
Add the following in `~/.bash_profile`
```txt
if [-z "${DISPLAY}" && ["${XDG_VTNR}" -eq 1]] then
    exec startx
fi
```


### xorg-xinput  
A tool to manage input devices
CMD                             | DEScription  
--                              | --  
xinput list                     | show devices


## libinput  
A library to handle input devices  
Default configuration file is in `/usr/share/X11/xorg.conf.d/40-libinput.conf`

CMD                             | Description
--                              | --  
libinput list-devices           | show devices

**Note**: this method can't change touchpad to natural scrolling for my laptop

## xf86-input-synaptics
`sudo pacman -S xf86-input-synaptics`

Use synaptics driver for touchpad.

Synaptics is a human interface hardware and software manufacturer.

Default configuration file: `/usr/share/X11/xorg.conf.d/70-synaptics.conf`  
Copy to `/etc/X11/xorg.conf.d/` and edit here

### Touchpad Natural Scorrling  
In `/etc/X11/xorg.conf.d/70-synaptics.conf` file, add following to identifer 'touchpad catchall'
```
Option "VertScrollDelta" "-111"
Option "HorizScrollDelta" "-111"
```
### Touchpad one-click confirm
```
Option "TapButton1" "1"
```

## Battery   
Check battery: acpi
Or using the command `cat /sys/class/power_supply/BAT0/capacity`


## Font  

System-wide font directory:'/usr/local/share/fonts'  
System-wide font directory:`/usr/share/fonts`, for pacman, shouldn't be modifies manually

ttf is a kind of font

Make sure you have `pacman -S fontconfig` installed.
And then you can use `fc-list` to list all fonts

## Setfont

`setfont` to set font in cli mode.
Example as follows:
`setfont /usr/share/kbd/consolefonts`



## VScode  
Format code: `Ctrl + Shift + I`

## User Management  
Information about all users: `/etc/passwd`
Information about all groups: `/etc/group`

Each user has a default primary group and some other secondary groups(15 max)


CMD                                | Description
--                                 | --
`id username`                      | get id of user
`useradd username`                 | add user
`passwd username`                  | assign/change passwd to a user
`usermod -u new_id username`       | change id of a user
`usermod -g new_group_id username` | change group of a user
`usermod -l new_name old_name`     | only change login name
`usermod -d new_home_dir username` | change home direcotry of a user
`usermod -r username`              | delete a user
`groups username`                  | get user's group format:(primary secondary)
`usermod -a -G sec_group username` | add a secondary group to user


| CMD      | Desc            |
|----------|-----------------|
| `groups` | Show all groups |


## Permission  
`ls -l filename`  show permission of a file  

-rw-r--r--  

Part    | Description
--      | -- 
`-`       | type of file(d for directory, s for special, - for regular file)
`rw-`     | owner's permission to file
`r--`     | members of the same group's permission
`r--`     | all other users' permission


## pandoc
Convert from one markup format to another  

| CMD                                                    | Description                                                |
| ------------------------------------------------------ | ---------------------------------------------------------- |
| pandoc -o output.html input.md                         | -o to specify the output, only produce document fragment   |
| pandoc -s -o output.html input.md                      | --standalone, produce complete document                    |
| pandoc -f markdown -t latex hello.txt                  | --from, --to, specify the input/output format              |
| pandoc sample.md -f gfm -o sample.pdf                  | --from github style markdown to                            |
| pandoc test.txt -o test.pdf                            | Create a PDF file                                          |
| pandoc -f html -t markdown www.xxx.com                 | Read from a website                                        |
| pandoc --extract-media ./img input.docx -o output.md   | Docx to md with images                                     |
| pandoc --highlight-style pygments                      | Add syntax highlighting                                    |
| pandoc --print-highlight-sytle=pygments > my.theme    | Print a theme, and edit it!                                |
| pandoc sample.md --highlight-style my.theme -o out.pdf | Use my edited theme file                                   |
| pandoc --toc --toc-depth <3> -V toc-title=<your_title> | Add table of contents with depth 3 and your content title  |
| pandoc --template eisvogel                             | Use a template, path from `~/.local/share/pandoc/templates`|

Some syntax highlight styles: `pygments, kate, monochrome, espresso, haddock, tango, zenburn`  

### Add chapter breaks

 `-H` `(--include-in-header)`, with tex file `chapter_break.tex` and content as follows 

```
\usepackage{sectsty}
\sectionfont{\clearpage}
```

With command `pandoc sample.md -f gfm -H chapter_break.tex -o sample.pdf`


### Change settings

`-V` `--variable`

```sh
#!/bin/bash
pandoc "$1" \
    -f gfm \
    --include-in-header chapter_break.tex \
    -V linkcolor:blue \
    -V geometry:a4paper \
    -V geometry:margin=2cm \
    -V mainfont="DejaVu Serif" \      # Normal text
    -V monofont="DejaVu Sans Mono" \  # Code snippet
    -V fontsize=12 \
    --pdf-engine=xelatex \
    -o "$2"
```






### keyboard

| CMD                            | Description         |
|--------------------------------|---------------------|
| `setxkbmap -print -verbose 10` | see X keyboard settings |


## KDE  

### SDDM
Default configuration file: ```/usr/lib/sddm/sddm.conf.d/default.conf```  
Configuration change: ```/etc/sddm.conf.d/```  
Autologin: ```/etc/sddm.conf.d/autologin.conf```  

## Swap Esp and Caps  

`setxkbmap -option caps:swapescape`. Add this to `.xinitrc`
Note that is requires $DISPLAY available

Alternative ways, this set swap permanently:

`loadkeys keys.conf`,

Content of keys.conf as follows:

```text
keycode 1 = Caps_Lock
keycode 58 = Escape
```

Linux version of VSC doen't respect remapping with xkbmap. To solve it, 
add `"keyboard.dispath": "keyCode"` in `settings.json`

##  Processes

### Show Processes   

`top` or `htop`  Display processes and memory use
`up/down` to navigate  
`k` to kill  

On top right, it shows info of command `uptime` and number of tasks,threads,kernel threads. 
And how many are running. See explanation of this command for details.

Press `F5` to see process tree(Which is parent proc and which is child proc)
By default, `htop` shows all threads. Press`<S-h>` to toggle thread and `<S-k>` to toggle kernel thread.

Attribute | Description  
----------| ----------
VIRT      | Amount of virtual memory
RES       | Resident size. Amount of physical memory  
SHR       | Amount of memory shared  
S         | State of process
TIME+     | Total CPU time consumed by process

State   | Description
--      | --
D       | uninterruptible sleep
R       | running  
S       | sleeping  
T       | traced or stopped  
Z       | zombie

Process Status command, display current running processes only
CMD     | Description
--      | --
`ps`    | start
`ps -u` | more information
`ps -A` | display all processes

### Kill Processes
CMD                 | Description
--                  | --
`kill (-9)[pid]`    | kill a process. -9 is SIGKILL, by default
`kill -L`           | list all signals
`killall [pname]`     | kill a process


### nproc

`nproc` returns number of cores in CPU.

### Uptime
Information from `/proc/uptime` and `/proc/loadavg`

Content of `/proc/loadavg`
```shell
0.74 0.56 0.42 1/417 316088
```
Average of number of processes being executed or in waiting state of last 1,5,15 minutes. 1 task running and 417 tasks in total. Last process id is 316088.

Note that one core in CPU can only execute one process at a time.
So if there's only one core in CPU, average load of 1 means 1 process was running on the CPU over last 1 minute, which means CPU was fully utilized.  
If load average is 0.4 for 5 minute period, it means CPU was idle by 60%.
If load average is 3.35 for 15 minute period, it means 2.35 process were waiting for CPU.

If the CPU has two cores, 
1.00 for 1 minute period means 1 core was being used one 1 core was idle.
0.40 for 5 minute period means CPU was idle by 160% on average.
3.35 for 15 minute minutes means 1.35 processes were waiting for CPU.


```shell
$ uptime
 13:10:42 up  4:38,  1 user,  load average: 0.76, 1.19, 0.95
```
which says system has been up for 4h38m.
Load average: average system load over a period of time.

### Process tree

Command `pstree` or `F5` in `htop`

## Vim  

### ColorScheme
`:colorscheme <scheme>`  Change color scheme  
Options:
blue       delek     evening    morning   peachpuff   slate  
darkblue   desert    industry   murphy    ron         torte  
default    elflord   koehler    pablo     shine       zellner  


Cmd                     | Description  
--                      | -- 
`gg`                    | Go to start of file
`G`                     | Go to end of file

## Makefile  

```
targets: prerequisites
    command
    command
    command(usually commands will create the file with the same name as target)
```
Example:  
```
hello:
  echo "Hello world"
  echo "Hahaha"
```

If no arguments are provided to `make` command, it will run the first target by default. If you provide an argument, it will only run the target with the same name as argument and necessary dependencies.

Notice the differences of the following two versions:  

```
blah:
  cc blah.c -o blah  # It won't recompile after blah.c is modified
```

```
blah: blah.c
  cc blah.c -o blah  # It will recompile after blah.c is modified
```

**IMPORTANT**: Make only run blah if blah doesn't exits or blah.c is newer than blah, which means it's better to add header file in the prequisite since editing header file may affect the compilation.

A more common template

```
blah: blah.o
  cc blah.o -o blah
blah.o: blah.c
  cc -c blah.c -o blah.o
clean:
  rm -f *.o blah
```

### Variables

Variables can only be strings.  
```
files := file1 file2  # Or file = file1 file2, Note quote is not required

executable: ${files}
  commands to create this executable

file1:
  touch file1
file2:
  touch file2

```


```
all: f1.o f2.o

f1.o f2.o:
  echo $@  # $@ contains target name, i.e. f1.o f2.o is this case
```

### Wildcard 
`*`: search in the filesystem for matched filenames   
```
thing_wrong := *.o # Don't do this! '*' will not get expanded
thing_right := $(wildcard *.o)

all: one two three four

# Fails, because $(thing_wrong) is the string "*.o"
one: $(thing_wrong)

# Stays as *.o if there are no files that match this pattern :(
two: *.o

# Works as you would expect! In this case, it does nothing.
three: $(thing_right)

# Same as rule three
four: $(wildcard *.o)
```

`%`: Matches one or more characters in a string or take the stem that was matched and replaces that in a string.

### Automatic Variables  

Variables | Description  
--        | --  
$@        | Name of the target of the rule
$%        | 
$<        | Name of the first prerequisite
$?        | Names of all prerequisites newer than target
$^        | Names of all prerequisites


### Implicit Rules  

In the following example, there's no rule to make foo.o bar.o. Make will use implicit rules to make these object files. The implicit rules are based on what kind of files you have and so on.    

Implicit rule will be applied for
1) each target without recipe
2) each double-colon rule without recipe 
```
foo: foo.o bar.o
    cc -o foo foo.o bar.o
```

```
foo.o: foo.c  # Implicit rules will be used
```

Variabels | Description  
--        | --  
CC        | Program for compiling C, usually `cc`
CXX       | Program for compiling C++, usually `g++` 
CFLAGS    | Extra flags to C compiler
CXXFLAGS  | Extra flags to C++
CPPFLAGS  | Extra flags to C preprocessor
LDFLAGS   | Extra flags to compilers when they are suppopsed to invoke the linker

Compile C program, file.c->file.o:  
`$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@`   
Compile C++ program, file.cpp->file.o:  
`$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@`  
Link object file, file.o->file:    
`$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@`  


### Static Pattern Rule  
Syntex:  
```
targets...: target-pattern: prereq-patterns
    commands
```
For example, the following two Makefiles are the same  
```
objects = foo.o bar.o all.o   
all:${objects}

foo.o: foo.c
bar.o: bar.c
all.o: all.c
```

```
objects = foo.o bar.o all.o
all:{Obejcts}

${objects}: %.o : %.c
```

### Target-specific variables  

One can define variables for specific targets or patterns

```
all: var = hello world

all:
    echo "var is set: ${var}"
other:
    echo "var is nothing: ${var}"
```

```
%.c: var = hello world

blah.c:
    echo "var is set: ${var}"
other:
    echo "var is nothing: ${var}"
```

### Makefile Condition  

```
foo = ok

all:
ifeq (${foo},ok)
    COMMANDS
else
    COMMANDS
endif
```

### Check if a variable is defined

```
all:
ifdef var
    COMMANDS
endif
ifndef var
    COMMANDS
endif
```

## picom  

Default configuration file: `/etc/xdg/picom.conf`

## xwallpaper  
`xwallpaper --zoom filename`

## ranger
Copy default configuration to `~/.config/ranger`: `ranger --copy-config=all`  
In `~/.config/ranger`, there are following files

file            | Description  
--              | --
`rc.conf`       | Keybinding and settings
`commands.py`   | commands launced with :
`rifle.conf`    | application used when given type of file is launced
`scope.sh`      | File Preview Settings


#### Console Commands  
Use `space` to select files  
Use `:` followed by commands

CMDs              | Description
--                | --
`:bulkrename`     | Rename in bulk
`:open_with`       | Open a select file with your chosen program
`:touch FILENAME` | create new file
`:mkdir FILENAME` | create new directory
`:shell COMMANDS` | run commands in a shell
`:delete`         | Delete files

Placeholder         | Description  
--                  | --
`%s`                | Currently select file
`%d`                | Current directory

#### Usual Commands

| CMDs                    | Description               |
|-------------------------|---------------------------|
| `i`                     | Preview File              |
| `r`                     | Open File                 |
| `zh/backspace` or <c-h> | toggling hidden files     |
| `gh`                    | Go to home directory      |
| `g/`                    | Go to root directory      |
| `cw`                    | Rename File               |
| `yy`                    | Copy file                 |
| `dd`                    | cut file                  |
| `dD`                    | delete file               |
| `pp`                    | paste file                |
| `z + letter`            | Changing settings         |
| `g + letter`            | Go to dir or operate tabs |
| `c + letter`            |                           |
| `y + letter`            |                           |
| `d + letter`            |                           |
| `p + letter`            | Different paste mode      |

#### Image Preview  
`set preview_images true` in `rc.conf` and change `preview_images_method`

#### PDF Preview
Uncomment the following part in "scope.sh"
```
# PDF  
 application/pdf)
    pdftoppm -f 1 -l 1 \

```

## imagemagick
Image viewer in terminal

`display filename`


## MariaDB
`mariadb -u root (-h) -p`

## fcitx5


## Git

### Configuration
Path                                                       | Description
--                                                         | --
`/etc/gitconfig``git config --system`                      | config to all users and repos
`~/.gitconfig/ ~/.config/git/config` `git config --global` | config personally to this user and all your repos
`.git/config` in repo `git config --local`                 | specifict to this single repository(default)
`git config --list --show-origin`                          | view all settings
`git config <key>`                                         | check a specific key
`git config --global user.name "sth"`                      |
`git config --global user.email sth`                       | `git config user.name ` to override this setting in a specific repo
`git config --global core.editor vim`                      | set editor


### Useful commands

| Commands                               | Description              |
|----------------------------------------|--------------------------|
| `git branch -r`                        | Show all remote branches |
| `git push origin --delete branch_name` | Delete remote branch     |
| 'git show <commit hash>'              | Show details of a commit |
| 'git push -f origin <branch> '       | force remote commit to be same as local(used to reset remote commit) |


## xrandr  

Used to manage output of a screen including resolution and refresh rate
Can be used to enable multiple monitors.  

Commands                                                                 | Description
--                                                                       | --
xrandr (-q)                                                              | List information of monitors
xrandr --output <MONITOR NAME> --auto                                    | Turn on monitor using default config
xrandr --output <MONITOR NAME> --off                                     | Turn off monitor
xrandr --output <MONITOR NAME> --mode <resolution> --rate <refresh rate> | Change the resolution and refresh rate


## pamixer  
Aka amixer. But can be configured with pacman. A volume level controller

## curl
Client URL
Used to transfer data to/from a server
`curl [options] [URL...]`


Command                     | Description
--                          | --
curl URL                    | Display content of a website(Get request to server)
curl -o FILE URL            | Save the downloaded file in local file
curl -O URL                 | Save the downloaded file in a file with the same name as URL

Example

1. Save the website, Note that `https//` can't be ignored
```bash
curl -o kernel.html https://www.kernel.org
```
2. Download a file in the website. Sed txt and pdf example here
```bash
curl -O https://www.gnu.org/software/sed/manual/sed.txt
curl -O https://www.gnu.org/software/sed/manual/sed.pdf
```
3. Redirects, no https/ (-I displays only the request header)
```bash
curl -I www.kernel.org
```
The command will say 301 moved permanently. The useful Location is
presented as `https://www.kernel.org` with Location key in the output

Use `--location (-L)` to redo the request with new position. This will represent the result
```bash
curl -L www.kernel.org
```

4. Combined together
```bash
curl -o -L kernel.html www.kernel.org
```


## cat  

CMD                    | Description
--                     | --
`cat filename`         |
`cat -n filename`      | show with line numbers
`cat > newfile`        | create new file
`cat src1 src2 > dest` | copy content from srcfile to dest
`cat src >> dest`      | append file1 to file2
`cat -s filename`      | no repeated empty line


## x86 Assembly  
```text
.data                      # readable/writable
data_item:                 # data_items points to 3
.long 3,5,6,7              # declare an array of numbers with 4bytes(consecutive)

.text                      # readable/executable
 
.global _start

_start:                    # entry to instruction
    
```
.quad: 8bytes  
.word: 2bytes

```
.rept 3
.long 0
.endr           # repeat sequence of lines 3 times
```
equivalent to 

```
.long 0
.long 0
.long 0
```

## Find Command

`find [where to start searching] [expression to find] [-options] [what to find]`


| Cmd                                       | Description                          |
|-------------------------------------------|--------------------------------------|
| find . -name sample.txt                   | Find sample.txt in current directory |
| find . -name *.txt                        | Find *.txt in current directory      |
| find . -name sample.txt -exec rm -i {} \; | Confirm if delete or not             |
| find * -not -type f -regex ".*sth.*\|.*sth2.*" -delete   | Find all files in cur dir and subdir that do not match required regex pattern (and delete them using pipeline)|

Find using multiple conditions, e.g.
```
find . -name \( -name '*.sv' -o -name '*.v' \) -not -name '*parameters.sv'
```
`-o` means `-or`, `-a` means `-and`. Not the use of `\( \)` to enforce precedance, which is necessary.


## Sed Command  
Sed stands for stream editor. Used for inserting, deleting, searching or replacing sth in file and print the result to stdout. It WON'T modify the original file

Commands                    | Description  
--                          | --  
sed 's/unix/linux/' FILE    | Replace unix with linux in the file, only replace the first occurence of the pattern in each line
sed 's/unix/linux/2' FILE   | Replace the second occurence of unix in the file
sed 's/unix/linux/g' FILE   | g:Global. Replace all occurences  
sed 's/unix/linux/3g' FILE  | Replace from 3th occurence to all occurences **in a line**
echo "have a nice day" | sed -E 's/([a-z])/\(\1\)/g' | Add parenthesis to every letter. -E to enable extended regular expression so that () doesn't need backslash before it. \1 to represent the matched pattern
sed '3 s/unix/linux/' FILE  | Replace only the third line
sed '1,3 s/unix/linux/' FILE| Replace from the first line to the third line
sed '2,$ s/unix/linux/' FILE| $ means last line, replace from second line to the last line
sed '5d' FILE               | Delete 5th line of the file
sed '3,6d' FILE             | Delete 3rd to 6th line of the file
sed '/abc/d' FILE           | Delete pattern matching line
sed 'G' FILE                | Insert a blank line after each line
sed '/love/G' FILE          | Insert a blank line after each line with matching pattern love


s: substitution  
/: delimiter


## Awk Command

awk is used for manipulating data.  
`awk [options] 'selection criteria' <input file>`

Note:  
Record: Each record is separated by a record separator, by default the separator is newline
Field: Each field is separated by a field separator, by default the separator is whitespace


Built-in Variables  | Description  
--                  | --  
NR                  | current number of input records/lines
NF                  | current number of fields(separate by whitespace) in current line
FS                  | Current Field Separator, by default whitespace
RS                  | current Record Separator, by default newline
OFS                 | Output Field Separator, by default whitespace, when print several parameters separator with commas, it prints value of OFS between each parameter
ORS                 | Output Record Separator, by default newline. print ORS at the end of whatever it is given to print

Command                               | Description
--                                    | --
awk '{print}' FILE                    | Print the content of the file
awk '/manager/ {print}' FILE          | Print all lines matching the pattern 'manager'
awk '{print $1,$4}' FILE              | Split each line based on whitespace and print the 1st and 4th field
awk '{print NR,$0}' FILE              | Display line number, $0 stands for all contents of current record
awk 'NR==3, NR==6 {print $0}' FILE    | Display from 3rd line to 6th line
awk '{print $1 "-" $2}'               | Field 1 and 2 are separated by "-"
awk 'END {print NR}' FILE             | Count the number of lines in the file
awk 'length($0) > 10' FILE            | Print lines with length larger than 10
awk '{if($3 == "B6") print $0;}' FILE | Find string in specific column


## Cut Command
Cut out sections from each line of files and print to stdout.  
`cut OPTIONS FILES`

Options                | Description
--                     | --
-b                     | Cut by byte
-c                     | Cut by character
-f                     | Cut by Field, tab is default delimiter, use -d to specify delimiter
--complement           | Complement the result
--output-delimiter='$' | Change the delimiter to $ in the output printed result

Commands                | Description  
--                      | --
cut -b 1,2,3 file       | Display byte 1,2,3 of each line
cut -b 1-3,5-7 file     | Display byte 1-3,5-7 of each line
cut -b 1- file          | Display byte from 1st to end
cut -c 1,2,3 file       | Display character 1,2,3 of each line
cut -d " " -f 1 file    | delimiter set to space. Display field 1, i.e. first word of each line

## Head Command & Tail Command
Head: Print top N numbers of file, default 10  
Tail: Print bottom N numbers of file  
It can be used as a filter  
`head OPTIONS FILE`  


Commands                | Description  
--                      | -- 
`head -n 5 file`          | Print first 5 lines of the file
`head -c 3 file`          | Print first 3 character of the file
`head -n 20 file \| tail -10`    | Print lines 10-20



## Regular Expression

Example 1:
```bash
$echo 'abc' | sed 's/./xyz/g'
xyzxyzxyz  
```
Here a dot means **any character**  

Example 2:  
```bash
$echo 'abc' | sed 's/\./xyz/g'
abc
```
Use back slash to avoid interrept dot as regular expression

Example 3:  
```bash
$echo 'a..b..c' | sed 's/[\.b]/d/g'
adddddc
$echo 'a..b..c' | sed 's/[\.b]\+/d/g'
adc
$echo 'a..b ..c' | sed 's/[\.b]\+/d/g'
ad dc
$ echo 'a..b..c' | sed 's|[\.b]\+|d|g; s|[a-c]|d|g'
ddd
```
`[\.b]`: Any literal dot or character b  
`\+`: Look for at least one, possibly more of listed characters and the matched pattern will be considered as only a single occurence. Here `\+` is not a literal `+`.  
`[a-c]`: A range of letters from a to c  


Example 4:
```bash
$echo "have a nice day" | sed 's/$/ you all/'
have a nice day you all
```
`$`: means end of line

Example 5:  
```bash
$echo "sample+" | sed 's/[a-e]+/_/g'
sampl_  # Here + is just a +
$echo "sample+" | sed -E 's/[a-e]+/_/g'
s_mpl_+ # Here + is not a +
```
-E: Enable Extended Regex.  In extended regex, + just means /+

Example 6:
```bash
$echo "abcdefghijklmnopqrstuvwxyz ABCDEFG 0123456789" | sed -E 's/([a-o]+).*([A-Z]+)/\2 \1/'  
G abcdefghijklmno 0123456789
```
`.*`:Any character, 0 or more times.It starts matching after character o and it will keep matching characters until the last A-Z are matched. This part is not captured by sed
`\2 \1`: Change the order of lower-case letters(first search pattern) and upper-case letters( second search pattern )

Example 7 (Easier version of Example 6):  
```bash
$echo "have a nice day " | sed 's/e.*e//g'
hav day
$echo "have a nice day " | sed 's/e.*//g'
hav
$echo "have a nice day " | sed 's/.*e//g'
 day
$echo "have a nice day " | sed 's/.*[a-d]//g'
y
$echo "have a nice day " | sed 's/e.*[a-d]//g'
havy 
```
Example 8:  
```bash
$echo "abcdefghijklmnopqrstuvwxyz ABCDEFG 0123456789" | sed -E 's/[^ ]*/_/'
_ ABCDEFG 0123456789
```
`[^ ]*`: Match any non-space character, 0 or more times. ^ in [] means not

Example 9:
```bash
$ echo "have a nice day" | sed -E 's/[^ ]+ [^ ]+//'
 nice day
```
`[^ ]+ [^ ]+` means the pattern of no-space space no-space  

**Summary**

Metacharacters | Example         | Description
--             | --              | --
[]             | [a-m],[0-9AF-Z] | A set of characters
[^ ]           | [^A-Za-z]       | Outside the selected range
.              | he..o           | Any character
\*              | he.*o*          | Zero or more occurences, usually followed by other metacharacters like .*
\+              | he.+o           | One or more occurences
?              | he.?o           | Zero or one occurences
{}             | he.{2}o         | Exactly specified number of occurences
^              | ^hello          | Start of the string
$              | planet$         | End of the string
`|`            | `fall|stays`    | Either or
\d             |                 | One digit
\D             |                 | One non-digit
\s             |                 | One whitespace
\S             |                 | One non-whitespace
\b             |                 | Backspace character
\n             |                 | Newline character
\t             |                 | Tab character


### Greedy match and Non-greedy match

Taking Python re as an example, `.*` is greedy match, trying to match the longest possible sequence of characters that are allowed to match   
`.*?` is non-greedy match, trying to match shortest possible sequence of characters that are allowed to match

For example
```
text = "Hello World"
H.*o => Hello Wo
H.*?o => Hello
```




## Bash

### Commands  
Every part separated is called **word** 
Arguments are separated by blankspace with command, `[]` is also a command'
`[-f file]` (wrong)   
`[ -f file ]` (correct)  

In Bash, almost everything is string (command, argumetns etc)

### Types of commands  
**Alias**: A way of shortening a cmd, only in interactive shell  
**Functions**  
**Builtins**: builtin commands 
**Keywords**: part of Bash syntax
**Executable**  

### Empty Space
Use double quote if there's whitespace belongs to one word
`var=a b` is wrong and `var="a b"` is correct


### Special Characters  
Character | Description
--        | --
`[[  ]]`  | *Test* - evaluation of a conditional expression
`{}`      | *Inline group* - cmds inside are treated as one cmd
`()`      | *Subshell group* - cmds insde are executed in a subshell
`((  ))`  | *Arithmetic expression* - +,-,* inside are treated as operator
`$((  ))` | the expression will be replaced with the reuslt of arithmetic evaluation  
`\`       | *Escape* - Prevents next character from being interpreted as a special character.

### Quotation

Double quotes can be used for strings containing spaces. Some times, it's not necessary to wrap a variable with double quotation like `"$var"`,but it is always a good idea to do so.  
Single quote will cause Bash to interpret string literally  
Back quote allow us to execute command  

```bash
echo $var         - > hello world
echo "$var"       - > hello world (a better habit)
echo '$var'       - > $var
echo '"'"$var"'"' - > "hello world" (put single quote around double quote so that it is interrrepted literally)
echo \""$var"\"   - > "hello world" (escape double quote so that it is printed)
```

### Parameter Expansion  

`$var` variable expansion
`${var}s` Seperate s from the variable
`$(command)`  command expansion  
`$((expression))`  arithmetic expansion
```
$ echo "'$USER', '$USERs','${USER}s'"
'autentico', '', 'autenticos'
```
### String Concatenation  

Example                     | Description
--                          | --
`var=$var1$var2`            | Concatenate two variables

Command                     | Description  
--                          | --  
`${#parameter}`             | length of parameter in character, if parameter is array, it returns the length of array  
`${parameter#pattern}`      | delete pattern from start, match against start, short
`${parameter##pattern}`     | delete pattern from start, use longest match from start
`${parameter%pattern}`      | delete pattern from end, match against end, short
`${parameter%%pattern}`     | delete pattern from end, use longest match from end
`${parameter/pat/string}`   | replace first pat with string, string can be null
`${parameter//pat/string}`  | replace every pat with string
`${parameter/#pat/string}`  | match against beginning, useful to add prefix
`${parameter/%pat/string}`  | match against end, useful to add suffix

```
$var=1.5.9
${var#*.}   -> 5.9
${var##*.}  -> 9
```

### Substring  
`${VAR:start_index:length}   # start_index from 0`  
`${MYSTR:11:4}`


### Command Substitution
Insert the output of one command into a second command  
Example: `cur_time=$(date)`  


### Parameters
Parameters include *variables* and *special parameters*  
variable: parameters that are denoted by a name  
special parameters: not denoted by a name  

Assign a variable  
`varname=data`  
Access data using *parameter expansion*   
`echo "$varname"`



Special Parameters | Description
--                 | --
`0`                | name/path of the script
`1,2,3`            | *Positional Parameters* arguments passed to current script
`*`                | Expands to all words to all positional parameters. If double quoted, it expands a string containing them all
`@`                | Expands to all words to all positional parameters. If doube quoted, it expands to a list containing them all
`#`                | Number of postional parameters currently set
`?`                |
`$`                | PID of current shell
`!`                | PID of command most recently executed
`_`                | last argument of last cmd executed

To expand these parameters, add $ before them

Predefined Variables            | Description  
--                              | --  
BASH_VERSIOn                    |
HOSTNAME                        |
PPID                            | PID of parent process of shell
PWD                             | current working directory
RANDOM                          |
UID                             | ID of current user
COLUMNS                         | width of terminal in characters
LINES                           | height of terminal in characters
HOME                            |
PATH                            |



### Variable Types
Command               | Type
--                    | --
`declare -a/array=()` | Array
`declare -A`          | Associative array
`declare -i `         | Integer, rarely used
`declare -r`          | Read Only



### Glob Patterns
Glob=normal character + metacharacter

Metacharacter               | Description  
--                          | --  
\*                           | Match any string
?                           | Match any single character
\[...]                       | Match any one of enclosed character

### Extended Glob  
Enable extended glob using `shopt -s extglob`

Metacharacter   | Description  
--              | -- 
?(list)         | Match zero or one occurence of pattern
*(list)         | Match zero or more occurence of pattern  
+(list)         | Match one or more occurence of pattern 
@(list)         | Match one of given patterns
!(list)         | Match anything but given patterns

list: list of (extended) globs separated by `|`  
```bash
$ ls
names.txt  tokyo.jpg  california.bmp
$ echo !(*jpg|*bmp)
names.txt
```

### Brace Expansion
```bash
$ echo th{e,a}n
then than
$ echo {/home/*,/root}/.*profile
/home/axxo/.bash_profile /home/lhunath/.profile /root/.bash_profile /root/.profile
$ echo {1..9}
1 2 3 4 5 6 7 8 9
$ echo {0,1}{0..9}
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19
```

### Exit Status  
Each command has an exit status. Range 0-255, 0 means success. `$?` to get exit code of last command


### Control Operator (&& || )
`&&`: If the first command return exit code 0, it will execute the next command.  
`||`: If the first command doesn't return exit code 0, it will execute the next command. Useful for simple error handling
`!`: Negate

### Grouping Statements
Use `{}` to group statements and the group is considered as one statement instead of several.  
Example. Without grouping, which will execute `echo` even though the first command fails:
```bash
$ grep -q goodword "$file" && ! grep -q badword "$file" && rm "$file" || echo "Couldn't delete: $file" >&2
```
With grouping, which is correct:
```bash
$ grep -q goodword "$file" && ! grep -q badword "$file" && { rm "$file" || echo "Couldn't delete: $file" >&2; }
```

### Conditional Blocks

`if` will check the exit code of `COMMAND1`. If it's 0, it will execute the `then` part  
```bash
if COMMAND1
then COMMAND2
elif COMMAND3
then COMMAND4
else COMMAND5
fi
```

Test command:`[]` or 'test' and `[[]]`, test things and return an exit status 
`[ a = b ]` 
`[[]]` allows pattern matching while `[]` doesn't  
`= != < > ` treat their arguments as strings   
`-eq -ne -lt -gt -le -ge` treat arguments as numbers

Tests           | Description
--              | --
-e FILE         | if file exists
-f FILE         | if is regular file
-d FILE         | if is directory
-s FILE         | if file exists and not empty
-r FILE         | if file is readable
-w FILE         | if file is writable
-x FILE         | if file is executable
FILE1 -nt FILE2 | if file1 is newer than file2
FILE1 -ot FILE2 | if file1 is older than file2
-z STRING       | if string is empty
-n STRING       | if string is not empty

Tests support by `[[]]`
Tests             | Description
--                | --
STRING = PATTERN  | if string matches the glob pattern
STRING == PATTERN | same as above
STRING != PATTERN | if string doesn't match the glob pattern
STRING =~ REGEX   | if string matches the regex


### Conditional Loops

```bash
while COMMAND
do COMMAND
done

for ((i=10; i > 0; i--))
do COMMAND
done

for i in {10..1}
do COMMAND
done
```

### Choices  
```bash
case $LANG in 
    en*) COMMAND ;;
    fr*) COMMAND ;;
    de*) COMMAND ;;
    *) COMMAND ;;
esac
```

If use `;&`, the block of next code will be executed no matter if pattern for that choice matches or not  
If use `;;*`, the block of next code will be executed depending on if the condition satisfies

```bash
select choice in A B C
do
echo "Your choice $choice"
done
```

### Arrays  

#### Declare an array:  
`names=("Bob" "Peter" "Big John")`  
`names=([0]="Bob" [1]="Peter" [20]="Big John")`  
`names[0]="Bob"`  
`unset 'names[1]' #remove an element to make in sparse`
`array=("$(array[@])")  # Reindex to remove holes in sparse array`
`photos=(~/pictures/*.jpg)`  
`file=(*)`

In order to parse stream(e.g. Output of a command) into elements of array, we can use NUL byte to indicate where each element starts and ends. As output of a command often can make its output separated by NUL.

#### Print a (array) variable

```bash
$declare -p names
declare -a names=([0]="Bob,Peter,Big John")
```
```bash
echo "${file[@]}"
echo "${file[0]}"
echo "${#file[@]}"  # Length of an array
```

```bash
printf '%s\n' "${file[@]}"   # $@: Expands to a list of words, with each array element as one word. 
```

```bash
for file in "${file[@]}"
do COMMAND
done
```

Remember always to quote properly!  

```bash
$for name in ${names[@]}; do echo $name; done
Bob
Peter
Big
John

$for name in "${names[@]}"; do echo $name; done
Bob
Peter
Big John

$for name in ${names[*]}; do echo $name; done
Bob
Peter
Big
John

$for name in "${names[*]}"; do echo $name; done
Bob Peter Big John  # If you use *, it will be a string

```


#### Expanding Indices  
```bash
$echo "${!names[@]}"
0 1 2       # In this way, you get the index of an array and can possibly use a for loop iterating indices.
```

#### Associative Array
```bash
declare -A fullNames    # declare an associate array
fullNames=( ["Bob"]="Bobbe Lorry" ["Peter"]="Pettery Parker" )
declare -p fullNames
echo "${fullNames['Bob']}"
```
Context in \[...] in a indexed array is arithmetic, you can do math here without wrapping using \$((...)).  

For indexed array, index in [...] part doesn't need a dollar sign$, but for associated array, an dollar sign is required. 
```bash
$ indexedArray=( "one" "two" )

$ declare -A associativeArray=( ["foo"]="bar" ["alpha"]="omega" )

$ index=0 key="foo"

$ echo "${indexedArray[$index]}"

one

$ echo "${indexedArray[index]}"

one

$ echo "${indexedArray[index + 1]}"

two

$ echo "${associativeArray[$key]}"

bar

$ echo "${associativeArray[key]}"

$ echo "${associativeArray[key + 1]}"

```



### Command Line Arguments
```
myfile arg1 arg2 arg3  
$0     $1   $2   $3   # $@ is set of all positional parameters
```
If you `shift` $1, $1 goes away and $2 becomes $1, $3 becomes $2 and so on

### File Descriptors  
Reference to files and other resources like files.
By default, there are three FDs:  
    + stdin, FD 0, from keyboard
    + stdout, FD 1, display on monitor
    + stderr, FD 2, display on monitor

`read`: read info from *stdin* and store in a variable  
`-p`: print according message
`read -p "What's your name?" name_variable`

### Redirection  
Redirection works by changing what FD points to. For example, change FD1 points to stdout to regular file.  

Redirection         | Description  
--                  | --  
`>`                 | Output redirection, stdout will write to a file 
`<`                 | Input redirection , stdin will read from a file 
`>>`                |

By default, if you simply type `cat`, it will read input from `stdin` and print to `stdout`. You can do some changes using redirection  

`cat < story`

Use number to denote FD that will be changed
`command > file`  
`command 1> file`
`command < file`
`command 0< file`

`rm file_that_not_exist 2> errors  # store error log in a file`
```
for sth in sths
do COMMAND
done 2> errors      # redirection applies to all output to stderr inside the loop
```

Ignore error message.  
`COMMAND 2> /dev/null`




### File Descriptor Manipulation


### grep
Reads the files and searches for the pattern provided.

`grep PATTERN FILEs` (from stdin if no file indicated)  
`grep -r `     # supports directories, it will search all files in this directories


Options             | Description  
--                  | --  
-c                  | Print only the count of lines matching the pattern
-i                  | Ignore case
-n                  | Display matched lines and their line numbers
-v                  | Print all lines that don't match the pattern
-l                  | Display list of filenames only
-w                  | Must match whole, substring won't be matched
-e                  | For multiple patterns, used to specify expressions



Command                 | Description  
--                      | --  
grep -l PATTERN *       | Display file containing this pattern
grep "^PATTERN" file    | Display lines that start with the pattern
grep -e "PATTERN1" -e "PATTERN2" file | Use multiple patterns
grep -A1 PATTERN file   | Display matched lines and 1 line after result
grep -B1 PATTERN file   | Display matched lines and 1 line before result
grep -C1 PATTERN file   | Display matched lines and 1 line before and after result


In the following command, two indenpendent FDs point to the same file.
The second FD points to beginning of `proud.log` and it will overwrite the information.  
`grep proud file not_file > proud.log 2> proud.log`  
Result in proud.log:  
```
grep: not_file: No such file or directory
 not and this is really amazing.
```


In the following command,`>&1` duplicate FD1 to FD2. Write to these FDs are the same and there's no mix-up.  
`grep proud file not_file > proud.log 2>&1`
Result in proud.log:  
```
file:I am proud whatever you believe it or not and this is really amazing.
grep: not_file: No such file or directory
```

### Heredoc and Herestring

Embed short blocks of multi-line data in to the command  
Example of heredoc:
```bash
cat << CONTENT  
>This is
>Really
>Amazing
CONTENT
```

Example of herestring:
`stdin` read information from string after `<<<`
`grep proud <<< "I am really proud"` 



### FIFO  
`mkfifo FILENAME`  
Create a special file, first write, first read, read will block until write to the file. Write will block until another process read FIFO.  


### Pipe  
Connects `stdout` of one process to `stdin` of another.  
Pipe operator will create a subshell environment for each command, so variables you modify inside the second command will appear unmodified outside of it.    


### Process Substition  
`>(command)` write  
`<(command)` read, run the command inside the parentheses and give a temporary filename that you can use.
Example   
`diff <(sort file1) <(sort file2)`


### Subshell  
Create subshell explicitly using parentheses `()`  
Any variables set during subshell are not remembered  
`(cd /tmp || exit 1; date > timestamp)`  
If `cd` fails, `exit 1` will terminate the subshell instead of the interactive shell.

### Command Grouping  
use `{}` to group commands.Separate commands with semicolon and there must be a semicolon after the last command. Or you can write commands in multiple lines. Basically it has no effect. But it allows a collection of commands to be considered as a whole with regard to redirection and control flow.`if, for, while` are already compound commands which behave like command grouping.  
If you use redirection to a command group, the file FD point to will only open once and close once, instead of opening the file and closing the file for each command in the group.


### Arithmatic Evaluation  
```bash
$a=2+3         # a is '2+3'
$let a=2+3     # a is 5
$let a='2 + 3' # a is 5
$((a=2+3))     # a is 5, which is arithmatic evaluation 
$echo $((a*b)) # arithmatic substitution  
```
`((abs = (a>0) ? a : -a))`  
`if ((flag)); then COMMAND; fi      # note $ sign is not required`  


### Functions
```bash
sum(){
    echo "$1 + $2 = $(($1 + $2))"
}
$sum 1 3
1 + 3 = 4
```
```bash
#!/bin/bash
count() {
    local i         # Local variable in the function
    for ((i=1; i<=$1; i++)); do echo $i; done
    echo 'Ah, ah, ah!'
}
for ((i=1; i<=3; i++)); do count $i; done
```

To remove a variable, alias or a function:  
`unset -f myfunction`  
`unset -v myvariable`
`unalias myalias`

### Sourcing  
When a script finishes its execution, its environment is discarded.  
`. ./myscript`  
If you use the dot operation, the script will run in current shell's environment. So Current shell's variables, working directory, functions etc will be changed.


## LaTex

### Commonly used package

tikz: create graphic elements  
graphicx: include figures


### Common fonts

| Commands                                  | Description               |
|-------------------------------------------|---------------------------|
| \renewcommand{\familydefault}{\rmdefault} | Set default font to roman |
| \renewcommand{\familydefault}{\sfdefault} | Set default font to sans  |


| Font                   | Command   | Switch Command | Decription       |
|------------------------|-----------|----------------|------------------|
| roman serif            | \textrm{} | \rmfamily      | Default for text |
| sans serif             | \textsf{} | \sffamily      |                  |
| typewritter(monospace) | \texttt{} | \ttfamily      |                  |



## Escape Character  

Many characters have special meaning. To treat this character as normal characer, add \
Shell as example, which I often confuse with other things.  

| Command                     | Output                                                          |
|-----------------------------|-----------------------------------------------------------------|
| `mkdir double dir`          | Will create two directories                                     |
| `mkdir double\ dir`         | Will create one directory named 'double dir', '\ ' escape space |
| `echo "\"`                  | Won't echo anything                                             |
| `echo "\\"`                 | print `\`                                                       |
| `echo "called "amazing""`   | print "called amazing"                                          |
| `echo "called \"amazing\""` | print "called "amazing"                                         |
| `echo what's`               | Won't work                                                      |
| `echo what\'s`              | Print "what's"                                                  |
| `echo "what's"`             | Print "what's"                                                  |
| `grep -R that's .`          | Won't work                                                      |
| `grep -R that\'s .`         | Works properly
| `grep -R "that's" .`        | Works properly                                                  |



## RAM

- RAM
    - DRAM (Dynamic RAM) uses capacitor. Needs refreshing. High capacity, speed low, cost low. The refreshing takes time so it slows down. Used as main memory
        - ADRAM (Asynchronous DRAM). No synchronization so there may delay in memory response.
        - SDRAM (Synchronous DRAM). System clock Synchronizes memory access.
    - SRAM (Static RAM), uses flip-flop. Long term storage. Low capacity, speed high, cost high. Used as cache

Dynamic - Refreshing - Slow


## Pip

Pip externally-managed-environment error:
Remove `/usr/lib/python3.x/EXTERNALLY-MANAGED`



## Du

Estimate file space usage
```
du -sh
```

| Common flags | Description                     |
|--------------|---------------------------------|
| -a           | Count for all files             |
| -h           | --human-readable                |
| -s           | --summarize. Only display total |



## Markdown

Some common markdown supported language
- bash(*.sh)
- c(*.c,*.h)
- cpp(*.cpp)
- css
- html
- ini(*.ini)
- java
- js(*.js)
- lua(*.lua)
- make(Makefile)
- python
- sql(*.sql)
- tex(*.tex)
- text(*.txt)
- vim(*.vim,.vimrc)


## Trash

directory of Trash: `~/.local/share/Trash/`

## wc 

wc -- print new line, word and byte counts for each file

newline: -l

Count number of files in current directory
```
ls | wc -l
```


## ssh

To generate ssh 
```
ssh-keygen -t ed25519 -C "your_mail"
```

```
ssh_keygen -t rsa -C "your_mail"

```

ssh server without password
```
ssh-copy-id -i ~/.ssh/id_rsa.pub <server_ip>
```

## GDB

If a program has forked some processes and to track the forked process  
```
(gdb) set follow-fork-mode child(parent)
```

## tee
Read from stdin and write to both stdout and file
```
echo "Hello" | tee myfile
```

## C 

C headfer files located in `/usr/include/`


## (IP) Internel Protocol

`sudo pacman -S net-tools bind`

Private IP range:  
10.0.0.0 to 10.255.255.255  
172.16.0.0 to 172.31.255.255  
192.168.0.0 to 192.168.255.255  


| Cmd                                           | Remark                        |
|-----------------------------------------------|-------------------------------|
| `ip addr`                                     | Private IP                    |
| `ifconfig`                                    | Private IP                    |
| `host myip.opendns.com resolver1.opendns.com` | Public IP, shown at last line |








